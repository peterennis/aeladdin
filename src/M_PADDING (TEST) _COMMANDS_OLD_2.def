Option Compare Database
Option Explicit

' RESEARCH
' Using the VBA Extensibility Library = Ref: http://pubs.logicalexpressions.com/pub0009/LPMArticle.asp?ID=307
' Ref: http://www.everythingaccess.com/mdeprotector_example.htm
' Ref: http://www.everythingaccess.com/vbwatchdog.htm
' Ref: http://www.officekb.com/Uwe/Forum.aspx/excel-prog/69455/Print-VBA-code-in-Editor-format-colors
' Ref: http://www.programmerworld.net/resources/visual_basic/visual_basic_addin.php
' Comment Out VBA Code Blocks = Ref: http://www.ozgrid.com/forum/showthread.php?t=10432&page=1
'

Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

' There is source code here on how to make an extended search
' http://kandkconsulting.tripod.com/VB/VBCode.htm##AddIN

' Ref: http://www.vbforums.com/showthread.php?t=479449
' Made By Michael Ciurescu (CVMichael)
'
' Modifications by Peter F. Ennis for aeladdin(TM)

Private mstrPotentialComment As String
Private maStrModulesList() As String
Private mstrAllCodeObjectsList() As String

Private BlockStart() As String
Private BlockEnd() As String
Private BlockMiddle() As String

Public Sub TestMyReNumberLeftAndAutoIndent(strSkipModule As String)
'    TestMyReNumberLeftAndAutoIndent "(TEST) _COMMANDS_OLD_2"
'
'    Do not renumber the module with the renumber function (i.e. this one)
'    It will crash Access.
'    A copy of the function is in modules "(_) aeNum"
    
7       On Error GoTo TestMyReNumberLeftAndAutoIndent_Error
    
9       Dim objVBAProject As Object
10      Set objVBAProject = Application.VBE.ActiveVBProject
11      MyReNumberAndLeftAlign objVBAProject, strSkipModule
12      MyReNumberAndLeftAlign objVBAProject, strSkipModule
    
14      Dim i As Integer
    
16      mstrAllCodeObjectsList = aeListCodeModules(strSkipModule)
    
18      Debug.Print "UBound(aeListCodeModules)=" & UBound(aeListCodeModules(strSkipModule))
19      Debug.Print "UBound(mstrAllCodeObjectsList)=" & UBound(mstrAllCodeObjectsList)
    
21      Debug.Print "TestMyReNumberLeftAndAutoIndent:"
    
23      IndentInitialize
    
25      For i = 1 To UBound(mstrAllCodeObjectsList)
26          If mstrAllCodeObjectsList(i) <> strSkipModule Then
27              Debug.Print i, mstrAllCodeObjectsList(i)
28              MyIndentCodeModule mstrAllCodeObjectsList(i)
'            Sleep 3000
30          End If
31      Next i
'    Debug.Print "First time"
33      EmptyLines objVBAProject, strSkipModule
'    Second time should have no output in immediate window when testing
'    Debug.Print "Second time"
'    EmptyLines objVBAProject, strSkipModule
    
38      On Error GoTo 0
    Exit Sub
    
41 TestMyReNumberLeftAndAutoIndent_Error:
    
43      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure TestMyReNumberLeftAndAutoIndent of Module (TEST) _COMMANDS_OLD_2"
    
End Sub

Private Sub TestRemoveLineNumbers(strSkipModule As String)
'    TestRemoveLineNumbers "(_) _COMMANDS_OLD_2"
    
3       Dim objVBAProject As Object
4       Set objVBAProject = Application.VBE.ActiveVBProject
    RemoveLineNumbers objVBAProject, strSkipModule
    
End Sub

Private Sub Test_aeOLDListCodeModules()
    
2       Dim i As Integer
3       Dim strSkipModule As String
4       strSkipModule = "(TEST) _COMMANDS_OLD_2"
    
6       mstrAllCodeObjectsList = aeListCodeModules(strSkipModule)
    
8       Debug.Print "UBound(mstrAllCodeObjectsList)=" & UBound(mstrAllCodeObjectsList)
    
10      For i = 1 To UBound(mstrAllCodeObjectsList)
11          Debug.Print mstrAllCodeObjectsList(i)
12      Next i
    
End Sub

Private Sub TestMyIndentCodeModule(strTheModuleName As String)
'    Ref: http://www.cpearson.com/excel/vbe.aspx
'    Set a reference to Microsoft Visual Basic for Applications Extensibility Library 5.3
    
4       On Error GoTo TestMyIndentCodeModule_Error
    
6       Dim objVBComp As VBIDE.VBComponent
7       Dim CodeMod As VBIDE.CodeModule
8       Dim objVBAProject As Object
    
10      Set objVBAProject = Application.VBE.ActiveVBProject
11      Set objVBComp = Application.VBE.ActiveVBProject.VBComponents.Item(strTheModuleName)
12      Set CodeMod = objVBComp.CodeModule
    
14      Debug.Print , objVBComp.Name
    
16      IndentInitialize
17      IndentCodeModule objVBAProject, CodeMod
    
19      On Error GoTo 0
    Exit Sub
    
22 TestMyIndentCodeModule_Error:
    
24      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure TestMyIndentCodeModule of Module (TEST) _COMMANDS_OLD_2"
    
End Sub

Private Sub TestMyReNumberAndLeftAlign()
'    Do not renumber the module with the renumber function (i.e. this one)
'    It will crash Access.
'    A copy of the function is in modules "(_) aeNum"
    
5       Dim objVBAProject As Object
6       Set objVBAProject = Application.VBE.ActiveVBProject
7       MyReNumberAndLeftAlign objVBAProject, "(TEST) _COMMANDS_OLD_2"
    
End Sub

Private Sub TestSplitLineAtLastApostrophe()
    
2       Dim str As String
    
4       str = "test it ' here"
    
6       If SplitLineAtLastApostrophe(str, mstrPotentialComment) Then
7           Debug.Print "TestSplitLineAtLastApostrophe: str>" & str & "<", "mstrPotentialComment>" & mstrPotentialComment & "<"
8       End If
    
End Sub

Private Function zzzaeListModules(Optional varDebug As Variant) As String()
'    Ref: http://www.exceltip.com/st/Array_variables_using_VBA_in_Microsoft_Excel/509.html
'    ====================================================================
'    Author:   Peter F. Ennis
'    Date:     March 17, 2011
'    Comment:  Add explicit references for DAO
'    ====================================================================
'
    
9       Dim dbs As DAO.Database
10      Dim cnt As DAO.Container
11      Dim doc As DAO.Document
12      Dim i As Integer
13      Dim j As Integer
14      Dim astr() As String
15      Dim blnDebug As Boolean
    
17      On Error GoTo aeListModules_Error
    
19      If IsMissing(varDebug) Then
20          blnDebug = False
21      Else
22          blnDebug = True
23      End If
    
'    Use CurrentDb() to refresh Collections
26      Set dbs = CurrentDb()
    
28      Set cnt = dbs.Containers("Modules")
29      j = cnt.Documents.count
'    Debug.Print "cnt.Documents.Count=" & j
31      ReDim astr(1 To j)
32      i = 1
33      For Each doc In cnt.Documents
34          If Not (Left(doc.Name, 3) = "zzz") Then
'            Application.SaveAsText aTheCodeModule, doc.Name, aegitType.SourceFolder & "\" & doc.Name & ".bas"
'            Debug.Print i, doc.Name
37              astr(i) = doc.Name
38              i = i + 1
39          End If
40      Next doc
    
'    For i = 1 To UBound(aStr)
'    Debug.Print aStr(i),
'    Next
    
46      zzzaeListModules = astr
    
48      Set doc = Nothing
49      Set cnt = Nothing
50      Set dbs = Nothing
    
52      On Error GoTo 0
    Exit Function
    
55 aeListModules_Error:
    
57      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure aeListModules of Module (_) aeNum"
    
End Function

Private Function SplitLineAtLastApostrophe(ByVal str As String, ByVal strRestOfLine As String) As Boolean
'    Ref: http://vbadud.blogspot.com/2008/11/how-to-return-multiple-values-from-vba.html
'    InStr Ref: http://www.ozgrid.com/forum/showthread.php?t=19252&page=1
'    NOTE: Parsing a code line to get an inline comment is sophisticated
'    This routine returns the string including the last apostrophe in mstrPotentialComment
'    Peter F. Ennis, March 2011
    
7       Dim i As Integer
8       Dim Pos As Integer
    
'    Debug.Print "str=" & str
11      Pos = InStr(str, "'")
12      If Pos = 0 Then
13          strRestOfLine = ""
14          SplitLineAtLastApostrophe = False
15      ElseIf Pos = 2 Then            ' A space is forced in the first character position
16          strRestOfLine = ""
17          SplitLineAtLastApostrophe = False
18      Else
19          mstrPotentialComment = Mid(str, Pos, Len(str))
'        Debug.Print "SplitLineAtLastApostrophe: InStr(1, mstrPotentialComment, strRestOfLine)>" & InStr(1, mstrPotentialComment, strRestOfLine) & "<"
21          If InStr(1, mstrPotentialComment, strRestOfLine) > 0 Then
22              SplitLineAtLastApostrophe = True
23          Else
24              SplitLineAtLastApostrophe = True
25          End If
'        Debug.Print "SplitLineAtLastApostrophe: str>" & str & "<", "Pos>" & Pos & "< ", "mstrPotentialComment>" & mstrPotentialComment & " < """
27      End If
    
End Function

Private Sub TestKeywordInComment()
    
2       Dim str As String
3       Dim bln As Boolean
    
5       str = "    x = 1             ' i do declare    "
6       Debug.Print "TestKeywordInComment: str>" & str & "<"
7       bln = KeywordInComment(str, "Declare")
8       Debug.Print "TestKeywordInComment: bln>" & bln & "<", "mstrPotentialComment>" & mstrPotentialComment & "<"
    
End Sub

Private Function KeywordInComment(str As String, strKeyWord As String) As Boolean
    
2       Dim bln As Boolean
    
4       bln = SplitLineAtLastApostrophe(str, strKeyWord)
    
6       If bln Then
7           KeywordInComment = True
8       Else
9           KeywordInComment = False
10      End If
    
'    Debug.Print "KeywordInComment>" & KeywordInComment & "<", "str>" & str & "<", "strKeyWord>" & strKeyWord & "<"
    
End Function

Private Function VBComponentExists(VBCompName As String, Optional VBProj As VBIDE.VBProject = Nothing) As Boolean
'    Ref: http://www.cpearson.com/excel/vbe.aspx
'    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'    This returns True or False indicating whether a VBComponent named
'    VBCompName exists in the VBProject referenced by VBProj. If VBProj
'    is omitted, the VBProject of the Active Application is used.
'    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
7       Dim VBP As VBIDE.VBProject
8       If VBProj Is Nothing Then
9           Set VBP = Application.VBE.ActiveVBProject
10      Else
11          Set VBP = VBProj
12      End If
13      On Error Resume Next
14      VBComponentExists = CBool(Len(VBP.VBComponents(VBCompName).Name))
    
End Function

Private Function aeListCodeModules(strSkipModule As String) As String()
'    Ref: http://www.exceltip.com/st/Array_variables_using_VBA_in_Microsoft_Excel/509.html
'    ====================================================================
'    Author:   Peter F. Ennis
'    Date:     March 17, 2011
'    Comment:  Add explicit references for DAO
'    ====================================================================
'
    
9       Dim objAccess As AccessObject  'Each module/form/report.
'    Dim dbs As DAO.Database
'    Dim cnt As DAO.Container
'    Dim doc As DAO.Document
13      Dim i As Integer
14      Dim j As Integer
15      Dim astr() As String
'    Dim blnDebug As Boolean
    
18      On Error GoTo aeListCodeModules_Error
    
'    If IsMissing(blnDebug) Then
'    bDebug = False
'    Else
'    bDebug = True
'    End If
    
'    Use CurrentDb() to refresh Collections
'    Set dbs = CurrentDb()
    
'    Set cnt = dbs.Containers("Modules")
30      j = CurrentProject.AllModules.count
'    Debug.Print "cnt.Documents.Count=" & j
32      ReDim astr(1 To j)
33      i = 1
34      For Each objAccess In CurrentProject.AllModules
35          If Not (Left(objAccess.Name, 3) = "zzz") And objAccess.Name <> strSkipModule Then
'            Application.SaveAsText aTheCodeModule, objAccess.Name, aegitType.SourceFolder & "\" & doc.Name & ".bas"
'            Debug.Print i, objAccess.Name
38              astr(i) = objAccess.Name
39              i = i + 1
40          End If
41      Next objAccess
    
43      ReDim Preserve astr(1 To i)
    
'    3811              i = i + 1
46      For Each objAccess In CurrentProject.AllForms
47          If Not (Left(objAccess.Name, 3) = "zzz") Then
'            Check if a CBF module exists
49              If VBComponentExists("Form_" & objAccess.Name) Then
50                  ReDim Preserve astr(1 To i)
51                  astr(i) = "Form_" & objAccess.Name
52                  i = i + 1
53              Else
54              End If
55          End If
56      Next objAccess
    
58      For Each objAccess In CurrentProject.AllReports
59          If Not (Left(objAccess.Name, 3) = "zzz") Then
60              If VBComponentExists("Report_" & objAccess.Name) Then
61                  ReDim Preserve astr(1 To i)
62                  astr(i) = "Report_" & objAccess.Name
63                  i = i + 1
64              Else
65              End If
66          End If
67      Next objAccess
    
'    If aeDebugIt Then
'    Debug.Print , "aeListCodeModules: aeDebugIt>" & aeDebugIt
'    For i = 1 To UBound(astr)
'    Debug.Print , i, astr(i)
'    Next
'    End If
    
76      aeListCodeModules = astr
    
'    Set doc = Nothing
'    Set cnt = Nothing
'    Set dbs = Nothing
    
82      On Error GoTo 0
    Exit Function
    
85 aeListCodeModules_Error:
    
87      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure aeListCodeModules of Module (_) aeNum"
    
End Function

Private Function zzzaeAllCodeObjectsList(Optional varDebug As Variant) As String()
'    ====================================================================
'    Author:   Peter F. Ennis
'    Date:     March 26, 2011
'    Comment:
'    ====================================================================
    
7       Dim objVBAProject As Object
8       Set objVBAProject = Application.VBE.ActiveVBProject
    
10      Dim objVBComponent As VBComponent
11      Dim blnDebug As Boolean
12      Dim i As Integer
13      Dim astr() As String
    
15      If IsMissing(varDebug) Then
16          blnDebug = False
17      Else
18          blnDebug = True
19      End If
    
21      i = 1
22      For Each objVBComponent In objVBAProject.VBComponents
23          ReDim Preserve astr(1 To i)
24          astr(i) = objVBComponent.Name
25          i = i + 1
'        Debug.Print objVBComponent.Name
27      Next
    
29      zzzaeAllCodeObjectsList = astr
    
End Function

Private Sub zzzTest_aeListModules()
    
2       Dim i As Integer
    
4       maStrModulesList = zzzaeListModules
    
6       For i = 1 To UBound(maStrModulesList)
7           Debug.Print maStrModulesList(i)
8       Next i
    
End Sub

Private Sub TestEmptyLines()
    
2       Dim objVBAProject As Object
3       Set objVBAProject = Application.VBE.ActiveVBProject
4       EmptyLines objVBAProject, "(_) _COMMANDS_"
    
End Sub

Private Sub EmptyLines(oVBP As VBProject, Optional strModuleName As Variant)
'    Peter F. Ennis, March 2011
    
3       Dim objVBComponent As VBComponent
4       Dim strProcName As String
5       Dim strOldName As String
6       Dim strLine As String
7       Dim iLine As Integer
8       Dim lngBodyLine As Long
9       Dim lngType As Long
10      Dim blnContinue As Boolean
11      Dim blnIsSelectCase As Boolean
12      Dim i As Integer
13      Dim strModName
    
15      On Error GoTo EmptyLines_Error
    
'    Do not renumber strModuleName
18      If IsMissing(strModuleName) Then
19          strModName = ""
20      Else
21          strModName = strModuleName
22      End If
    
24      i = 0
25      For Each objVBComponent In oVBP.VBComponents
26          i = i + 1
'        Debug.Print i, "objVBComponent.Name=" & objVBComponent.Name
28          If objVBComponent.CodeModule <> strModName Then
29              With objVBComponent.CodeModule
30                  strOldName = ""
31                  lngBodyLine = 0
                
33                  For iLine = 1 To .CountOfLines
34                      strLine = .Lines(iLine, 1)
                    
36                      strProcName = .ProcOfLine(iLine, lngType)
                    
38                      If strProcName <> strOldName Then
39                          lngBodyLine = .ProcBodyLine(strProcName, lngType)
40                      End If
                    
42                      If iLine > lngBodyLine And strProcName <> "" Then
'                        Debug.Print , "strLine>" & strLine & "<"
                        
45                          If IsNumeric(Left(strLine, InStr(1, strLine, " "))) Or Left(strLine, 1) = "'" Or Right(strLine, 1) <> " " Then
46                          Else
47                              .ReplaceLine iLine, Trim(strLine)
'                            For second time testing
'                            Debug.Print iLine, objVBComponent.Name, "strLine>" & strLine & "<"
50                          End If
51                      End If
                    
53                  Next
'                Sleep 1000
55              End With
56          End If
        
58      Next
    
60      On Error GoTo 0
    Exit Sub
    
63 EmptyLines_Error:
    
65      MsgBox "Error " & Err.Number & " (" & Err.description & ") in procedure EmptyLines of Module (_) aeNum"
    
End Sub

Private Sub RemoveLineNumbers(oVBP As VBProject, Optional strModuleName As Variant)
'    Peter F. Ennis, March 2011
    
3       Dim objVBComponent As VBComponent
4       Dim strProcName As String
5       Dim strOldName As String
6       Dim strLine As String
7       Dim iLine As Integer
8       Dim lngBodyLine As Long
9       Dim lngType As Long
10      Dim blnContinue As Boolean
11      Dim blnIsSelectCase As Boolean
12      Dim strModName
13      Dim Pos As Integer
    
15      On Error GoTo RemoveLineNumbers_Error
    
'    Do not renumber strModuleName
18      If IsMissing(strModuleName) Then
19          strModName = ""
20      Else
21          strModName = strModuleName
22      End If
    
24      For Each objVBComponent In oVBP.VBComponents
25          If objVBComponent.CodeModule <> strModName Then
26              With objVBComponent.CodeModule
27                  strOldName = ""
28                  lngBodyLine = 0
                
30                  For iLine = 1 To .CountOfLines
31                      strLine = .Lines(iLine, 1)
                    
33                      strProcName = .ProcOfLine(iLine, lngType)
                    
35                      If strProcName <> strOldName Then
36                          lngBodyLine = .ProcBodyLine(strProcName, lngType)
37                      End If
                    
39                      If iLine > lngBodyLine And strProcName <> "" Then
'                        Debug.Print , "strLine>" & strLine & "<"
                        
42                          If IsNumeric(Left(strLine, InStr(1, strLine, " "))) Then
43                              Pos = InStr(strLine, " ")
'                            If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
'                            Debug.Print "iLine>" & iLine, "Pos>" & Pos, "strLine>" & strLine
'                            End If
47                              .ReplaceLine iLine, Mid(strLine, Pos, Len(strLine) - Pos + 1)
48                          End If
49                      End If
                    
51                  Next
'                Sleep 1000
53              End With
54          End If
        
56      Next
    
58      On Error GoTo 0
    Exit Sub
    
RemoveLineNumbers_Error:
    
63      MsgBox "Error " & Err.Number & " (" & Err.description & ") in procedure RemoveLineNumbers of Module (_) aeNum"
    
End Sub

Private Sub MyReNumberAndLeftAlign(oVBP As VBProject, strModuleName As String)
'    Ref: https://groups.google.com/group/microsoft.public.excel.programming/browse_frm/thread/33b9b2b3cc22f9e3?hl=en&lr&pli=1
'    Set a reference to Microsoft Visual Basic for Applications Extensibility Library 5.3
'    Code example framework without GoTo
'    Ref: http://www.ozgrid.com/forum/showthread.php?t=120898&page=1
'    Ref: http://allenbrowne.com/vba-CountLines.html
'    Ref: http://sites.google.com/site/msaccesscode/vba-3/showerrorlineinvba
'
'    Peter F. Ennis, March 2011
'    Run it twice to take care of lines that initially have no numbers.
    
11      Dim objVBComponent As VBComponent
12      Dim strProcName As String
13      Dim strOldName As String
14      Dim strLine As String
15      Dim iLine As Integer
16      Dim lngBodyLine As Long
17      Dim lngType As Long
18      Dim blnContinue As Boolean
19      Dim blnIsSelectCase As Boolean
'    Dim i As Integer
'    Dim strModName
    
23      On Error GoTo ReNumberAndLeftAlign_Error
    
'    Debug.Print , "MyRenumberAndLeftAlign"
    
'    Do not renumber strModuleName
'    28      If IsMissing(strModuleName) Then
'    29          strModName = ""
'    30      Else
'    31          strModName = strModuleName
'    32      End If
    
'    i = 0
35      For Each objVBComponent In oVBP.VBComponents
'        i = i + 1
'        Debug.Print i, "objVBComponent.Name=" & objVBComponent.Name
38          If objVBComponent.CodeModule <> strModuleName Then
39              With objVBComponent.CodeModule
40                  strOldName = ""
41                  lngBodyLine = 0
                
43                  For iLine = 1 To .CountOfLines
44                      strLine = Trim(.Lines(iLine, 1)) & " "
                    
'                    If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
'                    Debug.Print "A:" & iLine & ", " & lngBodyLine, "strLine>" & strLine
'                    End If
                    
50                      If IsNumeric(Left(strLine, InStr(1, strLine, " "))) Then
                        
'                        Debug.Print iLine & " " & objVBComponent.Name & ">", strLine
'                        Debug.Print Left(strLine, InStr(1, strLine, " "))
'                        Debug.Print Mid(strLine, InStr(1, strLine, " "))
55                          .ReplaceLine iLine, Trim(Mid(strLine, InStr(1, strLine, " ")))
'                        If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
'                        Debug.Print "B:" & iLine & ", " & lngBodyLine, Trim(Mid(strLine, InStr(1, strLine, " ")))
'                        End If
59                      End If
                    
61                      strProcName = .ProcOfLine(iLine, lngType)
'                    If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
'                    Debug.Print "strProcName=" & strProcName, "iLine=" & iLine, "lngType=" & lngType, ".ProcOfLine(iLine, lngType)=" & .ProcOfLine(iLine, lngType)
'                    End If
65                      If strProcName <> strOldName Then
66                          lngBodyLine = .ProcBodyLine(strProcName, lngType)
67                      End If
                    
69                      If iLine > lngBodyLine And strProcName <> "" Then
                        
                        
'                        If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
'                        Debug.Print "C:" & iLine & ", " & lngBodyLine, "strLine>" & strLine
'                        Debug.Print "C1:" & iLine & ", " & lngBodyLine, "strLine>" & " " & Trim(.Lines(iLine, 1)) & " "
'                        End If
                        
                        
78                          strLine = " " & Trim(.Lines(iLine, 1)) & " "
79                          If strLine = "  " Then GoTo ptr_Next
80                          If Left(strLine, 2) = " '" Then GoTo ptr_Next
81                          If Left(strLine, 2) = " #" Then GoTo ptr_Next
82                          If Left(strLine, 4) = " Rem" Then GoTo ptr_Next
'
84                          If InStr(1, strLine, " = Split") > 0 And InStr(1, strLine, " strLine,") = 0 Then GoTo ptr_Continue
'                        If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
86                          If InStr(1, strLine, " Declare ") > 0 And InStr(1, strLine, " strLine,") = 0 And KeywordInComment(strLine, "Declare") Then GoTo ptr_Continue
87                          If InStr(1, strLine, " Sub ") > 0 And InStr(1, strLine, " strLine,") = 0 And KeywordInComment(strLine, "Sub") Then GoTo ptr_Continue
88                          If InStr(1, strLine, " Function ") > 0 And InStr(1, strLine, " strLine,") = 0 And KeywordInComment(strLine, "Function") Then GoTo ptr_Continue
89                          If InStr(1, strLine, " Property ") > 0 And InStr(1, strLine, " strLine,") = 0 And KeywordInComment(strLine, "Property") Then GoTo ptr_Continue
'                        End If
'
92                          If InStr(1, strLine, " Declare ") > 0 And InStr(1, strLine, " strLine,") = 0 Then GoTo ptr_Next
93                          If InStr(1, strLine, " Sub ") > 0 And InStr(1, strLine, " strLine,") = 0 Then GoTo ptr_Next
94                          If InStr(1, strLine, " Function ") > 0 And InStr(1, strLine, " strLine,") = 0 Then GoTo ptr_Next
95                          If InStr(1, strLine, " Property ") > 0 And InStr(1, strLine, " strLine,") = 0 Then GoTo ptr_Next
                        
97 ptr_Continue:
98                          strLine = .Lines(iLine, 1) & " "
99                          If IsNumeric(Left(strLine, 4)) Then strLine = Mid(strLine, 6)
100                         If IsNumeric(Left(strLine, InStr(1, strLine, " ") - 1)) Then strLine = Mid(strLine, InStr(1, strLine, " "))
101                         If Trim(strLine) = "" Then
102                             strLine = Trim(strLine)
103                         Else
104                             strLine = Format(iLine - lngBodyLine, "0000") & " " & strLine
105                         End If
'                        If objVBComponent.Name = "(_) Renumber_Bugs_Testing" Then
'                        Debug.Print "blnContinue=" & blnContinue, "blnIsSelectCase=" & blnIsSelectCase, iLine, strLine
'                        End If
109                         If Not blnContinue And Not blnIsSelectCase Then .ReplaceLine iLine, strLine
110                         If InStr(1, strLine, "Select Case") > 0 And InStr(1, strLine, " = Split(") = 0 Then
111                             blnIsSelectCase = True
112                         ElseIf InStr(1, strLine, "Case") > 0 And InStr(1, strLine, " = Split(") = 0 Then
113                             blnIsSelectCase = False
114                         ElseIf InStr(1, strLine, "End Select") > 0 And InStr(1, strLine, " = Split(") = 0 Then
115                             blnIsSelectCase = False
116                         End If
117                     End If
118 ptr_Next:
119                     blnContinue = (Right(Trim(strLine), 2) = " _")
120                 Next
'                Sleep 1000
122             End With
123         End If
        
125     Next
    
127     On Error GoTo 0
    Exit Sub
    
130 ReNumberAndLeftAlign_Error:
    
132     MsgBox "Error " & Err.Number & " (" & Err.description & ") in procedure ReNumberAndLeftAlign of Module (_) aeNum"
    
End Sub

Private Sub IndentInitialize()
1       BlockStart = Split("If * Then;For *;Do *;Do;Select Case *;While *;With *;Private Function *;Public Function *;Friend Function *;Function *;Private Sub *;Public Sub *;Friend Sub *;Sub *;Private Property *;Public Property *;Friend Property *;Property *;Private Enum *;Public Enum *;Friend Enum *;Enum *;Private Type *;Public Type *;Friend Type *;Type *", ";")
2       BlockEnd = Split("End If;Next*;Loop;Loop *;End Select;Wend;End With;End Function;End Function;End Function;End Function;End Sub;End Sub;End Sub;End Sub;End Property;End Property;End Property;End Property;End Enum;End Enum;End Enum;End Enum;End Type;End Type;End Type;End Type", ";")
3       BlockMiddle = Split("ElseIf * Then;Else;Case *", ";")
End Sub

Private Sub MyIndentCodeModule(strTheModuleName As String)
'    Ref: http://www.cpearson.com/excel/vbe.aspx
'    Set a reference to Microsoft Visual Basic for Applications Extensibility Library 5.3
    
4       On Error GoTo MyIndentCodeModule_Error
    
6       Dim objVBComp As VBIDE.VBComponent
7       Dim CodeMod As VBIDE.CodeModule
    
9       Dim objVBAProject As Object
10      Set objVBAProject = Application.VBE.ActiveVBProject
11      Set objVBComp = Application.VBE.ActiveVBProject.VBComponents.Item(strTheModuleName)
12      Set CodeMod = objVBComp.CodeModule
    
'    Debug.Print , objVBComp.Name
    
16      IndentCodeModule objVBAProject, CodeMod
    
18      On Error GoTo 0
    Exit Sub
    
21 MyIndentCodeModule_Error:
    
23      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure MyIndentCodeModule of Module (TEST) _COMMANDS_OLD_2"
    
End Sub

Private Sub IndentCodeModule(oVBP As VBProject, TheCodeModule As Object)
    
'    110      Dim objVBComponent As VBComponent
'    38          Set objVBComponent = TheCodeModule
    
5       On Error GoTo IndentCodeModule_Error
    
7       Dim AllCode As String
8       Dim AllLines() As String
9       Dim LineNumbers() As String
10      Dim k As Long
11      Dim Q As Long
12      Dim VBLine As String
13      Dim StartCursorPos As Long
14      Dim TopLine As Long
    
16      With TheCodeModule
17          TopLine = .CodePane.TopLine
18          .CodePane.GetSelection StartCursorPos, 0, 0, 0
        
20          AllCode = .Lines(1, .CountOfLines)
        
22          AllCode = Replace(AllCode, "_" & vbNewLine, "")
23          AllLines = Split(AllCode, vbNewLine)
24          ReDim LineNumbers(UBound(AllLines))
        
26          For k = 0 To UBound(AllLines)
27              Q = InStr(1, AllLines(k), " ")
28              If Q = 0 Then Q = InStr(1, AllLines(k), vbTab)
            
30              If Q > 0 Then
31                  If CStr(Val(Left(AllLines(k), Q - 1))) = Left(AllLines(k), Q - 1) Then
32                      LineNumbers(k) = Left(AllLines(k), Q - 1)
33                      AllLines(k) = Mid(AllLines(k), Q)
34                  End If
35              End If
            
37              AllLines(k) = Trim(AllLines(k))
            
39              If Left(AllLines(k), 1) = "'" Then
40                  AllLines(k) = "' " & Trim(Mid(AllLines(k), 2))
41              End If
42          Next k
        
44          IndentBlock AllLines
        
46          For k = 0 To UBound(AllLines)
47              VBLine = RemoveLineComments(AllLines(k))
            
49              For Q = 0 To UBound(BlockMiddle)
50                  If Replace(VBLine, vbTab, "") Like BlockMiddle(Q) And Left(VBLine, 1) = vbTab Then
51                      AllLines(k) = Mid(AllLines(k), 2)
52                  End If
53              Next Q
54          Next k
        
56          For k = 0 To UBound(AllLines)
57              If Len(LineNumbers(k)) > 0 Then
58                  AllLines(k) = LineNumbers(k) & vbTab & AllLines(k)
59              End If
60          Next k
        
62          AllCode = Replace(Join(AllLines, vbNewLine), Chr(1), "")
        
64          .DeleteLines 1, .CountOfLines
65          .InsertLines 1, AllCode
        
67          TheCodeModule.CodePane.SetSelection StartCursorPos, 1, StartCursorPos, 1
68          .CodePane.TopLine = TopLine
69      End With
    
71      On Error GoTo 0
    Exit Sub
    
74 IndentCodeModule_Error:
    
76      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure IndentCodeModule of Module (_) _COMMANDS_OLD_2"
    
End Sub

Private Sub IndentBlock(VBLines() As String)
    
2       On Error GoTo IndentBlock_Error
    
4       Dim k As Long
5       Dim Q As Long
6       Dim EndPos As Long
7       Dim VBLine As String
8       Dim StartPos As Long
9       Dim FoundStartEnd As Boolean
    
11      Do
12          StartPos = 0
13          EndPos = UBound(VBLines)
        
15          Do
16              FoundStartEnd = False
            
18              For k = EndPos To StartPos Step -1
19                  VBLine = RemoveLineComments(VBLines(k))
'                Debug.Print "VBLine=" & VBLine
                
22                  If Len(VBLine) > 0 Then
23                      For Q = 0 To UBound(BlockStart)
24                          If VBLine Like BlockStart(Q) Then
25                              StartPos = k + 1
26                              FoundStartEnd = True
27                              Exit For
28                          End If
29                      Next Q
                    
31                      If Q <= UBound(BlockStart) Then Exit For
32                  End If
33              Next k
            
35              If FoundStartEnd Then
36                  For k = StartPos To EndPos
37                      VBLine = RemoveLineComments(VBLines(k))
                    
39                      If Len(VBLine) > 0 Then
40                          If VBLine Like BlockEnd(Q) Then
41                              EndPos = k - 1
42                              FoundStartEnd = True
43                              Exit For
44                          End If
45                      End If
46                  Next k
47              End If
48          Loop While FoundStartEnd
        
50          If Not (Not FoundStartEnd And StartPos = 0 And EndPos = UBound(VBLines)) Then
'            Debug.Print StartPos, EndPos
52              IndentLineBlock VBLines, StartPos, EndPos
53          End If
54      Loop Until Not FoundStartEnd And StartPos = 0 And EndPos = UBound(VBLines)
    
56      On Error GoTo 0
    Exit Sub
    
59 IndentBlock_Error:
    
61      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure IndentBlock of Module (_) _COMMANDS_"
    
End Sub

Private Function RemoveLineComments(ByVal VBLine As String) As String
    
2       On Error GoTo RemoveLineComments_Error
    
4       Dim k As Long
5       Dim Q As Long
    
7       If InStr(1, VBLine, "'") > 0 Then
8           k = 1
9           Do
10              If Mid(VBLine, k, 1) = """" Then
11                  For Q = k + 1 To Len(VBLine)
12                      If Mid(VBLine, Q, 1) = """" Then
13                          VBLine = Left(VBLine, k) & Mid(VBLine, Q)
14                          k = k + 1
15                          Exit For
16                      End If
17                  Next Q
18              End If
            
20              k = k + 1
21          Loop Until k >= Len(VBLine)
        
23          For k = 1 To Len(VBLine)
24              If Mid(VBLine, k, 1) = "'" Then
25                  VBLine = Left(VBLine, k - 1)
26                  Exit For
27              End If
28          Next k
29      End If
    
    RemoveLineComments = Trim(VBLine)
    
33      On Error GoTo 0
    Exit Function
    
RemoveLineComments_Error:
    
38      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure RemoveLineComments of Module (_) _COMMANDS_"
    
End Function

Private Sub IndentLineBlock(VBLines() As String, ByVal StartLine As Long, ByVal EndLine As Long, Optional NoIndentChar As Byte = 1)
    
2       On Error GoTo IndentLineBlock_Error
    
4       Dim k As Long
    
6       If NoIndentChar > 0 Then
7           If StartLine > 0 Then VBLines(StartLine - 1) = Chr(NoIndentChar) & VBLines(StartLine - 1)
8           If EndLine < UBound(VBLines) Then VBLines(EndLine + 1) = Chr(NoIndentChar) & VBLines(EndLine + 1)
9       End If
    
11      For k = StartLine To EndLine
12          If Left(VBLines(k), 1) = "'" Then
13              VBLines(k) = "' " & vbTab & Mid(VBLines(k), 2)
14          Else
15              VBLines(k) = vbTab & VBLines(k)
16          End If
17      Next k
    
19      On Error GoTo 0
    Exit Sub
    
22 IndentLineBlock_Error:
    
24      MsgBox "Erl=" & Erl & " Error " & Err.Number & " (" & Err.description & ") in procedure IndentLineBlock of Module (_) _COMMANDS_"
    
End Sub